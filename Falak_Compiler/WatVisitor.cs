/*
    Falak compiler 
    Copyright (C) 2021 José Antonio Vázquez, Daniel Trejo y Jaime Orlando López. ITESM CEM
*/

using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace Falak
{

    class WatVisitor
    {
        public HashSet<string> GlobalVariableTable;
        public IDictionary<string, Type> GlobalFunctionTable;
        public IDictionary<string, HashSet<string>> SymbolTable;
        public int cycles, cantTabs;
        public int ret = 0;
        public string FunName;
        string block, passblock;
        public bool VarDefinitionBody, ArrayBody, isStatement, insideArray, isGlobal;

        public string tabs()
        {
            string regresar = "\t";
            for (int i = 0; i < cantTabs; i++)
            {
                regresar += "\t";
            }
            return regresar;
        }

        public string tabs(int sumar)
        {
            string regresar = "\t";

            if (sumar == -99 || sumar == -98)
            {
                regresar = "";
            }

            for (int i = 0; i < cantTabs; i++)
            {
                regresar += "\t";
            }

            if (sumar == -98)
            {
                cantTabs -= 1;
            }
            else if (sumar != -99)
            {
                cantTabs += sumar;
            }

            return regresar;
        }

        public WatVisitor(IDictionary<string, HashSet<string>> SymbolTable, HashSet<string> GlobalVariableTable, IDictionary<string, Type> GlobalFunctionTable)
        {
            this.GlobalVariableTable = GlobalVariableTable;
            this.GlobalFunctionTable = GlobalFunctionTable;
            this.SymbolTable = SymbolTable;
            this.VarDefinitionBody = false;
            this.ArrayBody = false;
            this.isStatement = false;
            this.insideArray = false;
            this.isGlobal = false;
        }

        public string Visit(Program node)
        {

            var regresar = ";; WebAssembly text format code generated by "
                + "the falak compiler.\n\n"
                + "(module\n"
                + " (import \"falak\" \"printi\" (func $printi (param i32) (result i32)))\n"
                + " (import \"falak\" \"printc\" (func $printc (param i32) (result i32)))\n"
                + " (import \"falak\" \"prints\" (func $prints (param i32) (result i32)))\n"
                + " (import \"falak\" \"println\" (func $println (result i32)))\n"
                + " (import \"falak\" \"readi\" (func $readi (result i32)))\n"
                + " (import \"falak\" \"reads\" (func $reads (result i32)))\n"
                + " (import \"falak\" \"new\" (func $new (param i32) (result i32)))\n"
                + " (import \"falak\" \"size\" (func $size (param i32) (result i32)))\n"
                + " (import \"falak\" \"add\" (func $add (param i32) (param i32) (result i32)))\n"
                + " (import \"falak\" \"get\" (func $get (param i32) (param i32) (result i32)))\n"
                + " (import \"falak\" \"set\" (func $set (param i32) (param i32) (param i32) (result i32)))\n";

            isGlobal = true;
            regresar += VisitChildren((dynamic)node)
                + ")\n";
            isGlobal = false;
            return regresar;

        }
       

        public string Visit(DefList node)
        {
            return VisitChildren((dynamic)node);
        }


        public string Visit(Var_Def node)
        {
            var variableName = node.AnchorToken.Lexeme;
            if (GlobalVariableTable.Contains(variableName) && isGlobal == true)
            {
                return tabs() + $"(global ${variableName} (mut i32) (i32.const 0))\n";
            }
            else
            {
                if (!VarDefinitionBody)
                {
                    return tabs() + $"(param ${node.AnchorToken.Lexeme} i32)\n";
                }
                else
                {
                    return tabs() + $"(local ${node.AnchorToken.Lexeme} i32)\n";
                }
            }

        }

        public string Visit(VarList node)
        {
            return VisitChildren((dynamic)node);
        }

        public string Visit(FunDef node)
        {
            isGlobal = false;
            FunName = node.AnchorToken.Lexeme;
            Console.WriteLine(FunName);
            ret = 1;
            string regresar = "";
            if (FunName == "main")
            {
                regresar = "\n" + tabs(1) + $"(func\n"
                + tabs() + "(export \"main\")\n"
                + VisitChildren((dynamic)node)
                + "i32.const 0\n"
                + tabs(-1)
                + "\n)";
            }
            else
            {
                regresar = "\n" + tabs(1) + $"(func ${node.AnchorToken.Lexeme}\n"
                + VisitChildren((dynamic)node)
                + "i32.const 0\n"
                + tabs(-1)
                + "\n)";
            }
            isGlobal = true;
            return regresar;
        }

        public string Visit(Var_DefList node)
        {
            VarDefinitionBody = true;
            var regreso = tabs() + "(local $_temp i32)\n" + VisitChildren((dynamic)node);
            VarDefinitionBody = false;
            return regreso;
        }

        public string Visit(ParamList node)
        {
            return VisitChildren((dynamic)node) + tabs() + "(result i32)\n";
        }
        public string Params(ParamList node)
        {
            string regresa = "\n";
            foreach (var nodeC in node)
            {
                regresa += tabs() + $"(param ${nodeC.AnchorToken.Lexeme} i32)\n";
            }
            return regresa;
        }

        public string Visit(StatementList node)
        {
            isStatement = true;
            var regresa = VisitChildren((dynamic)node);
            isStatement = false;
            return regresa;
        }

        public string Visit(StatementAssign node)
        {
            isStatement = false;
            if (node[0].getCount() > 1 && node[0].GetType() == new Expr_List().GetType())
            {
                string arr = "";
                foreach (var n in node[0])
                {
                    arr += tabs() + "local.get $_temp\n"
                    + Visit((dynamic)n)
                    + tabs() + "call $add\n"
                    + tabs() + "drop\n";
                }
                isStatement = true;
                return tabs() + "i32.const 0\n"
                + tabs() + "call $new\n"
                + tabs() + "local.set $_temp\n"
                + tabs() + "local.get $_temp\n"
                + arr
                + tabs() + $"{getVariableCategory(node)}.set ${node.AnchorToken.Lexeme}\n";
            }
            var regresar = Visit((dynamic)node[0])
                + tabs() + $"{getVariableCategory(node)}.set ${node.AnchorToken.Lexeme}\n";
            isStatement = true;
            return regresar;
        }

        public string Visit(StatementInc node)
        {
            return VisitChildren((dynamic)node)
                + tabs() + "i32.const 1\n"
                + tabs() + "i32.add\n"
                + tabs() + $"{getVariableCategory(node[0])}.set ${node[0].AnchorToken.Lexeme}\n";
        }

        public string Visit(StatementDec node)
        {
            return VisitChildren((dynamic)node)
                + tabs() + "i32.const 1\n"
                + tabs() + "i32.sub\n"
                + tabs() + $"{getVariableCategory(node[0])}.set ${node[0].AnchorToken.Lexeme}\n";
        }

        public string Visit(StatementIf node)
        {
            isStatement = false;
            var regresar = Visit((dynamic)node[0])
                + tabs(1) + "if\n";

            isStatement = true;
            regresar += VisitChildren((dynamic)node, 1)
            + tabs(-98) + "end\n";
            return regresar;
        }

        public string Visit(Else_If node)
        {
            if (node.getCount() == 0)
            {
                return "";
            }
            else
            {
                isStatement = false;
                var regresar = tabs(-99) + "else\n"
                + Visit((dynamic)node[0])
                + tabs(1) + "if\n";

                isStatement = true;
                regresar += VisitChildren((dynamic)node, 1)
                + tabs(-98) + "end\n";

                return regresar;
            }

        }

        public string Visit(Node_Else node)
        {
            if (node.getCount() == 0)
            {
                return "";
            }
            else
            {
                return tabs(-99) + "else\n"
                + Visit((dynamic)node[0]);
            }
        }

        public string Visit(StatementWhile node)
        {
            passblock = block;
            cycles += 1;
            block = formatNested();
            cycles += 1;
            var loop = formatNested();
            isStatement = false;

            string ret = tabs(1) + $"block ${block}\n"
                + tabs(1) + $"loop ${loop}\n\n"
                + Visit((dynamic)node[0]) + "\n"
                + tabs() + "i32.eqz\n"
                + tabs() + $"br_if ${block}\n\n";
            isStatement = true;

            ret += Visit((dynamic)node[1]) + "\n"
                + tabs(-1) + $"br ${loop}\n"
                + tabs(-1) + "end\n"
                + tabs() + "end\n";
            block = passblock;
            return ret;
        }

        public string Visit(StatementDo node)
        {
            passblock = block;
            cycles += 1;
            block = formatNested();
            cycles += 1;
            var loop = formatNested();
            isStatement = true;

            string ret = tabs(1) + $"block ${block}\n"
                + tabs(1) + $"loop ${loop}\n"
                + Visit((dynamic)node[0]) + "\n";
            isStatement = false;

            ret += Visit((dynamic)node[1]) + "\n"
                + tabs() + "i32.eqz\n"
                + tabs() + $"br_if ${block}\n\n"
                + tabs(-1) + $"br ${loop}\n"
                + tabs(-1) + "end\n"
                + tabs() + "end\n";
            block = passblock;
            isStatement = true;
            return ret;
        }

        public string Visit(StatementBreak node)
        {
            return tabs() + $"br ${block}\n";
        }

        public string Visit(StatementReturn node)
        {
            ret = 0;
            isStatement = false;
            if (node[0].getCount() > 1 && node[0].GetType() == new Expr_List().GetType())
            {
                string arr = "";
                foreach (var n in node[0])
                {
                    arr += tabs() + "local.get $_temp\n"
                    + Visit((dynamic)n)
                    + tabs() + "call $add\n"
                    + tabs() + "drop\n";
                }

                isStatement = true;
                return tabs() + "i32.const 0\n"
                + tabs() + "call $new\n"
                + tabs() + "local.set $_temp\n"
                + tabs() + "local.get $_temp\n"
                + arr
                + tabs() + "return\n";
            }
            var regresa = Visit((dynamic)node[0])
            + tabs() + "return\n";
            isStatement = true;
            return regresa;
        }

        public string Visit(Empty node)
        {
            return "";
        }

        public string Visit(Expr_List node)
        {
            if (ArrayBody == true)
            {
                var regresar = "";
                if (node.getCount() > 0)
                {
                    for (int i = 0; i <= node.getCount(); i++)
                    {
                        regresar += tabs() + "local.get $_temp\n";
                    }
                    foreach (var n in node)
                    {
                        regresar += Visit((dynamic)n)
                            + tabs() + "call $add\n"
                            + tabs() + "drop\n";
                    }
                }
                return regresar;
            }
            else
            {
                return VisitChildren((dynamic)node);
            }

        }

        public string Visit(Or node)
        {
            return Visit((dynamic)node[0])
                + tabs(1) + "if(result i32)\n"
                + tabs(-1) + "i32.const 1\n"
                + tabs(1) + "else\n"
                + Visit((dynamic)node[1])
                + tabs() + "i32.eqz\n"
                + tabs(-1) + "i32.eqz\n"
                + tabs() + "end\n";
        }

        public string Visit(Xor node)
        {
            return Visit((dynamic)node[0])
            + tabs() + "i32.eqz\n"
            + tabs() + "i32.eqz\n"
            + Visit((dynamic)node[1])
            + tabs() + "i32.eqz\n"
            + tabs() + "i32.eqz\n"
            + tabs() + "i32.xor\n"
            ;
        }

        public string Visit(And node)
        {
            return Visit((dynamic)node[0])
                + tabs(1) + "if(result i32)\n"
                + Visit((dynamic)node[1])
                + tabs() + "i32.eqz\n"
                + tabs(-1) + "i32.eqz\n"
                + tabs(1) + "else\n"
                + tabs(-1) + "i32.const 0\n"
                + tabs() + "end\n";
        }

        public string Visit(Compare node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + tabs() + "i32.eq\n";
        }

        public string Visit(Different node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + tabs() + "i32.ne\n";
        }

        public string Visit(Less_Than node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + tabs() + "i32.lt_s\n";
        }

        public string Visit(Less_Equal node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + tabs() + "i32.le_s\n";
        }

        public string Visit(More_Than node)
        {
            return Visit((dynamic)node[1])
                + Visit((dynamic)node[0])
                + tabs() + "i32.lt_s\n";
        }

        public string Visit(More_Equal node)
        {
            return Visit((dynamic)node[1])
                + Visit((dynamic)node[0])
                + tabs() + "i32.le_s\n";
        }

        public string Visit(Plus node)
        {
            return Visit((dynamic)node[0])
                 + Visit((dynamic)node[1])
                 + tabs() + "i32.add\n";
        }

        public string Visit(Minus node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + tabs() + "i32.sub\n";
        }

        public string Visit(Multiply node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + tabs() + "i32.mul\n";
        }

        public string Visit(Div node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + tabs() + "i32.div_s\n";
        }

        public string Visit(Mod node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + tabs() + "i32.rem_s\n";
        }

        public string Visit(Positive node)
        {
            return Visit((dynamic)node[0]);
        }

        public string Visit(Negative node)
        {
            return tabs() + "i32.const 0\n"
                + Visit((dynamic)node[0])
                + tabs() + "i32.sub\n";
        }

        public string Visit(Not node)
        {
            return Visit((dynamic)node[0])
                + tabs() + "i32.eqz\n";
        }

        public string Visit(Fun_Call node)
        {
            if (ArrayBody == true && insideArray == true)
            {
                ArrayBody = false;
            }
            if (isStatement == true)
            {
                if (node.getCount() > 0)
                {
                    isStatement = false;
                    var regresar = Visit((dynamic)node[0])
                    + tabs() + $"call ${node.AnchorToken.Lexeme}\n"
                    + tabs() + "drop\n";
                    isStatement = true;
                    if (ArrayBody == false && insideArray == true)
                    {
                        ArrayBody = true;
                    }
                    return regresar;
                }
                else
                {
                    var regresar = tabs() + $"call ${node.AnchorToken.Lexeme}\n"
                    + tabs() + "drop\n";
                    if (ArrayBody == false && insideArray == true)
                    {
                        ArrayBody = true;
                    }
                    return regresar;
                }
            }
            else
            {
                if (node.getCount() > 0)
                {
                    var regresar = Visit((dynamic)node[0])
                    + tabs() + $"call ${node.AnchorToken.Lexeme}\n";
                    if (ArrayBody == false && insideArray == true)
                    {
                        ArrayBody = true;
                    }
                    return regresar;
                }
                else
                {
                    var regresar = tabs() + $"call ${node.AnchorToken.Lexeme}\n";
                    if (ArrayBody == false && insideArray == true)
                    {
                        ArrayBody = true;
                    }
                    return regresar;
                }
            }
        }

        public string Visit(Var_Refer node)
        {
            return tabs() + $"{getVariableCategory(node)}.get ${node.AnchorToken.Lexeme}\n";
        }


        public string Visit(True node)
        {
            return tabs() + "i32.const 1\n";
        }

        public string Visit(False node)
        {
            return tabs() + "i32.const 0\n";
        }

        public string Visit(Int_Literal node)
        {
            return tabs() + $"i32.const {node.AnchorToken.Lexeme}\n";
        }

        public string Visit(CharLit node)
        {
            char[] str = node.AnchorToken.Lexeme.ToCharArray();
            int i = 1;
            int c = 0;
            if (str[i] == '\\')
            {
                i++;
                if (str[i] == 'n')
                {
                    c = 10;
                }
                else if (str[i] == '"')
                {
                    c = 34;
                }
                else if (str[i] == 'r')
                {
                    c = 13;
                }
                else if (str[i] == 't')
                {
                    c = 9;
                }
                else if (str[i] == '\\')
                {
                    c = 92;
                }
                else if (str[i] == '\'')
                {
                    c = 39;
                }
                else if (str[i] == 'u')
                {
                    string w = "";
                    w += str[i + 1];
                    w += str[i + 2];
                    w += str[i + 3];
                    w += str[i + 4];
                    w += str[i + 5];
                    w += str[i + 6];
                    c = int.Parse(w, System.Globalization.NumberStyles.HexNumber);
                    i += 6;
                }
            }
            else
            {
                c = Convert.ToInt32(str[1]);
            }
            return tabs() + $"i32.const {c}\n";
        }

        public string Visit(String_Lit node)
        {
            string regresar = tabs() + "i32.const 0\n"
            + tabs() + "call $new\n"
            + tabs() + "local.set $_temp\n"
            + tabs() + "local.get $_temp\n";
            char[] str = node.AnchorToken.Lexeme.ToCharArray();
            for (int i = 1; i < str.Length - 1; i++)
            {
                if (str[i] == '\\')
                {
                    i++;
                    var regresar2 = "";
                    if (str[i] == 'n')
                    {
                        regresar2 += tabs() + "local.get $_temp\n";
                    }
                    else if (str[i] == '"')
                    {
                        regresar2 += tabs() + "local.get $_temp\n";
                    }
                    else if (str[i] == 'r')
                    {
                        regresar2 += tabs() + "local.get $_temp\n";
                    }
                    else if (str[i] == 't')
                    {
                        regresar2 += tabs() + "local.get $_temp\n";
                    }
                    else if (str[i] == '\\')
                    {
                        regresar2 += tabs() + "local.get $_temp\n";
                    }
                    else if (str[i] == '\'')
                    {
                        regresar2 += tabs() + "local.get $_temp\n";
                    }
                    else if (str[i] == 'u')
                    {
                        regresar2 += tabs() + "local.get $_temp\n";
                        i += 6;
                    }
                    regresar += regresar2;
                }
                else
                {
                    regresar += tabs() + "local.get $_temp\n";
                }
            }
            for (int i = 1; i < str.Length - 1; i++)
            {

                if (str[i] == '\\')
                {
                    i++;
                    int c = 0;
                    if (str[i] == 'n')
                    {
                        c = 10;
                    }
                    else if (str[i] == '"')
                    {
                        c = 34;
                    }
                    else if (str[i] == 'r')
                    {
                        c = 13;
                    }
                    else if (str[i] == 't')
                    {
                        c = 9;
                    }
                    else if (str[i] == '\\')
                    {
                        c = 92;
                    }
                    else if (str[i] == '\'')
                    {
                        c = 39;
                    }
                    else if (str[i] == 'u')
                    {
                        string w = "";
                        w += str[i + 1];
                        w += str[i + 2];
                        w += str[i + 3];
                        w += str[i + 4];
                        w += str[i + 5];
                        w += str[i + 6];
                        c = int.Parse(w, System.Globalization.NumberStyles.HexNumber);
                        i += 6;
                    }
                    regresar += tabs() + "i32.const " + c + "\n";
                }
                else
                {
                    regresar += tabs() + "i32.const " + Convert.ToInt32(str[i]) + "\n";
                }
                regresar += tabs() + "call $add\n";
                regresar += tabs() + "drop\n";
            }
            return regresar;
        }


        public string Visit(Array node)
        {
            string regresar = tabs() + "i32.const 0\n"
            + tabs() + "call $new\n"
            + tabs() + "local.set $_temp\n";

            ArrayBody = true;
            insideArray = true;
            isStatement = false;
            string regresar2 = VisitChildren((dynamic)node);
            ArrayBody = false;
            isStatement = true;
            insideArray = false;
            return regresar + regresar2;
        }

        string VisitChildren(Node node)
        {
            var sb = new StringBuilder();
            foreach (var n in node)
            {
                sb.Append(Visit((dynamic)n));
            }
            return sb.ToString();
        }

        string VisitChildren(Node node, int cambio)
        {
            int i = 0;
            var sb = new StringBuilder();
            foreach (var n in node)
            {
                if (i >= cambio)
                {
                    sb.Append(Visit((dynamic)n));
                }
                i++;
            }
            return sb.ToString();
        }

        public string getVariableCategory(Node node)
        {
            foreach (var n in SymbolTable[FunName])
            {
                if (n == node.AnchorToken.Lexeme)
                {
                    return "local";
                }
            }
            return "global";
        }

        public string formatNested()
        {
            if (cycles < 10)
            {
                return "0000" + cycles.ToString();
            }
            else if (cycles < 100)
            {
                return "000" + cycles.ToString();
            }
            else if (cycles < 1000)
            {
                return "00" + cycles.ToString();
            }
            else if (cycles < 10000)
            {
                return "0" + cycles.ToString();
            }
            else
            {
                return cycles.ToString();
            }
        }

    }
}
